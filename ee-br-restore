#!/bin/bash

# Set bash environment error management

set -e
set -u

# Source local functions file

script_dir="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
. $script_dir/functions

# Check for root user runtime

check_root

################################################################################

# Source openspace functions file

source_os_functions

################################################################################

os-head_script

################################################################################

os-define_formatting

define_vars

check_config_file

# Source vars from config file

. $install_dir/config

################################################################################

install_easyengine

################################################################################

choice="${b}Is the backup you're trying to restore stored locally on this machine [i.e. you're trying to restore a previous state of this running instance of easyengine] or is it stored elsewhere [i.e. you're changing machine or your previous machine's data was wiped or lost]? ${x}"
echo "$choice"
echo
options=("backup file stored locally" "backup file stored elsewhere" "exit")
select opt in "${options[@]}"
do
    echo
    case $opt in
	"backup file stored locally")
	    restoresource=here
	    break
	    ;;
	"backup file stored elsewhere")
	    restoresource=elsewhere
	    break
	    ;;
	"exit")
	    echo "${b}Exiting...${x}"
	    echo
	    exit
	    ;;
	*)
	    echo "${r}${b}Invalid option. Retry...${x}"
	    echo
	    ;;
    esac
done

if [ $restoresource = "here" ]
then

	restore_from_here

else

        if [ "$backuptype" = "s3" ]
        then
                echo "${b}You've previously set up an S3 file storage server connection on this machine.${x}"
                echo
                choice="${b}Do you want to restore from S3 or from a standalone $short_name backup file you have stored individually? ${x}"
                echo "$choice"
		echo
                options=("S3" "standalone" "exit")
                select opt in "${options[@]}"
                do
                    echo
                    case $opt in
                        "S3")
                            restoretype=s3
                            break
                            ;;
                        "standalone")
                            restoretype=standalone
                            break
                            ;;
                        "exit")
                            echo "${b}Exiting...${x}"
                            echo
                            exit
                            ;;
                        *)  echo "${r}${b}Invalid option. Retry...${x}"
                            echo
                            ;;
                    esac
                done
        else
                restoretype=standalone
        fi



        if [ $restoretype = "s3" ]
        then

		restore_from_S3

        else

		restore_from_standalone

        fi

fi
echo

################################################################################

### Perform a [last] backup of this currently running installation just in case

echo "${b}Now backing up [locally - no S3 of course] this machine's currently running $short_name installation just in case...${x}"
echo

purge_and_create_dirs

update_storage_info noS3

purge_backups

backup_locally

echo "${b}Now compressing backup...${x}"
echo

cd $tmp_dir

### Tar.bz2 this backup archive. Give local backup a custom name so that it's clear it's the last one before a rollback in time

tar cSf - $backupname -P | pv -s $(du -sb $backupname | awk '{print $1}') | bzip2 > $archive_dir/$backupname-last-backup-before-"$now"-restore.tar.bz2

### If not restoring a previous state of this same installation, then move the backups directory to an "old" named one.

if [ $restoresource = "here" ]
then
        echo "${b}Backed up current installation to $archive_dir.${x}"
        echo
else
	mkdir -p "$backups_dir"/old
        mv "$archive_dir" "$backups_dir"/old/archive-old-before-"$now"-restore
	if [ ! $duplicitylogdir = "null" ]
	then
		mkdir -p "$duplicitylogdir"/old
	        mv "$duplicitylogdir"/backup/ "$duplicitylogdir"/old/backup-old-before-"$now"-restore 2> /dev/null || true
	fi
        echo "${b}Backed up current installation to local backups directory and moved the latter to $backups_dir/old/archive-old-before-$now-restore.${x}"
        echo
fi

################################################################################

echo "${b}Now restoring your old easyengine installation from backup...${x}"
echo

if [ $restoresource = "here" ]
then
        restore_file_name="$(echo "$sel_backup_file" | sed 's|./||g' | sed 's/-last-backup.*-restore//' | sed 's/.tar.bz2//g')"
        restorefileloc=$restores_dir/local/$restore_file_name
else
        if [ $restoretype = "s3" ]
        then
                restorefileloc=$restores_dir/s3
        else
                restorefileloc="/root/$short_name-restore"
        fi
fi

for site in $restorefileloc/*
do

	if [ -d "$site" ]
	then

		this_site="$(echo "$site" | sed "s|${restorefileloc}/||")"

		if [ ! $this_site = "22222" ] && [ ! $this_site = "html" ] && [ ! $this_site = "roundcubemail" ]
		then

			echo "${b}*] Now evaluating site | ${g}$this_site${x}${b} |: ${x}"
			echo
			www_site_dir="$www_dir/$this_site"

			proceed=y

			if [ -d $www_site_dir ]
			then

				echo "${r}${b}   This site already exists on this machine.${x}"
				echo
				read -rp "${b}   Delete it and re-create it restoring its respective backup? (Y/n): ${x}" -n 1
				echo
				if [[ ! $REPLY =~ ^[Nn]$ ]]
				then
					echo "${b}   Ok, proceeding...${x}"
					echo
					ee site delete $this_site --no-prompt
				else
					echo
					echo "${b}   Ok, skipping...${x}"
					echo
					proceed=n
				fi
			fi

			if [ $proceed = y ]
			then

				ee site create $this_site
				echo

				### Test to see if site to be restored is a wordpress site and if it is restore it while replacing new database details

				real_wp_config_file="$site/wp-config.php"
				if [ -f $real_wp_config_file ]
				then

					echo "${b}   Proceeding with ${l}wordpress${x}${b} site restore...${x}"
					echo

					ee site update $this_site --wpfc
					echo

					www_wp_config_file="$www_site_dir/wp-config.php"

					www_WPDBNAME=`cat $www_wp_config_file | grep DB_NAME | cut -d \' -f 4`
					www_WPDBUSER=`cat $www_wp_config_file | grep DB_USER | cut -d \' -f 4`
					www_WPDBPASS=`cat $www_wp_config_file | grep DB_PASSWORD | cut -d \' -f 4`

					old_WPDBNAME=`cat $real_wp_config_file | grep DB_NAME | cut -d \' -f 4`
					old_WPDBUSER=`cat $real_wp_config_file | grep DB_USER | cut -d \' -f 4`
					old_WPDBPASS=`cat $real_wp_config_file | grep DB_PASSWORD | cut -d \' -f 4`

					mv "$www_wp_config_file" "$www_wp_config_file.pre-restore-original-file"
					cp "$real_wp_config_file" "$www_wp_config_file"

					sed -i "s|${old_WPDBNAME}|${www_WPDBNAME}|g" "$www_wp_config_file"
					sed -i "s|${old_WPDBUSER}|${www_WPDBUSER}|g" "$www_wp_config_file"
					sed -i "s|${old_WPDBPASS}|${www_WPDBPASS}|g" "$www_wp_config_file"

					mysql -u"$www_WPDBUSER" -p"${www_WPDBPASS}" "${www_WPDBNAME}" < "$site/mysqldump.sql"

				else

					echo "${b}   Proceeding with ${m}NON wordpress${x}${b} site restore...${x}"
					echo
					read -rp "${b}   Activate PHP on restored site? (Y/n): ${x}" -n 1
					echo
					if [[ ! $REPLY =~ ^[Nn]$ ]]
					then
						echo "${b}   Ok, proceeding...${x}"
						echo
						ee site update $this_site --php
						echo
					else
						echo
						echo "${b}   Ok, skipping...${x}"
						echo
					fi

				fi

				if [ -d $site/htdocs/ ]
				then
					rsync -aAXx --delete "$site/htdocs/" "$www_site_dir/htdocs/"
				else
					echo "${r}${b}   No | htdocs | subdirectory found for site | $this_site |. Skipping...${x}"
					echo
				fi

				echo "${b}   Finished backup for | $this_site |.${x}"
				echo

			fi

		fi

	fi

done

rm -r "$tmpbackupdir"
if [ -d $tmp_dir ]
then
	rm -r ${tmp_dir:?}
fi

echo "${g}${b}Restore complete!${x}"
echo
